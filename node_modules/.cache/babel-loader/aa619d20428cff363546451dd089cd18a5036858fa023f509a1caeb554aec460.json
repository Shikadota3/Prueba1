{"ast":null,"code":"//import { Capacitor } from '@capacitor/core';\n/**\n * SQLiteConnection Class\n */\nexport class SQLiteConnection {\n  constructor(sqlite) {\n    this.sqlite = sqlite;\n    this._connectionDict = new Map();\n  }\n  async initWebStore() {\n    try {\n      await this.sqlite.initWebStore();\n      return Promise.resolve();\n    } catch (err) {\n      return Promise.reject(err);\n    }\n  }\n  async saveToStore(database) {\n    try {\n      await this.sqlite.saveToStore({\n        database\n      });\n      return Promise.resolve();\n    } catch (err) {\n      return Promise.reject(err);\n    }\n  }\n  async saveToLocalDisk(database) {\n    try {\n      await this.sqlite.saveToLocalDisk({\n        database\n      });\n      return Promise.resolve();\n    } catch (err) {\n      return Promise.reject(err);\n    }\n  }\n  async getFromLocalDiskToStore(overwrite) {\n    const mOverwrite = overwrite != null ? overwrite : true;\n    try {\n      await this.sqlite.getFromLocalDiskToStore({\n        overwrite: mOverwrite\n      });\n      return Promise.resolve();\n    } catch (err) {\n      return Promise.reject(err);\n    }\n  }\n  async echo(value) {\n    try {\n      const res = await this.sqlite.echo({\n        value\n      });\n      return Promise.resolve(res);\n    } catch (err) {\n      return Promise.reject(err);\n    }\n  }\n  async isSecretStored() {\n    try {\n      const res = await this.sqlite.isSecretStored();\n      return Promise.resolve(res);\n    } catch (err) {\n      return Promise.reject(err);\n    }\n  }\n  async setEncryptionSecret(passphrase) {\n    try {\n      await this.sqlite.setEncryptionSecret({\n        passphrase: passphrase\n      });\n      return Promise.resolve();\n    } catch (err) {\n      return Promise.reject(err);\n    }\n  }\n  async changeEncryptionSecret(passphrase, oldpassphrase) {\n    try {\n      await this.sqlite.changeEncryptionSecret({\n        passphrase: passphrase,\n        oldpassphrase: oldpassphrase\n      });\n      return Promise.resolve();\n    } catch (err) {\n      return Promise.reject(err);\n    }\n  }\n  async clearEncryptionSecret() {\n    try {\n      await this.sqlite.clearEncryptionSecret();\n      return Promise.resolve();\n    } catch (err) {\n      return Promise.reject(err);\n    }\n  }\n  async checkEncryptionSecret(passphrase) {\n    try {\n      const res = await this.sqlite.checkEncryptionSecret({\n        passphrase: passphrase\n      });\n      return Promise.resolve(res);\n    } catch (err) {\n      return Promise.reject(err);\n    }\n  }\n  async addUpgradeStatement(database, upgrade) {\n    try {\n      if (database.endsWith('.db')) database = database.slice(0, -3);\n      await this.sqlite.addUpgradeStatement({\n        database,\n        upgrade\n      });\n      return Promise.resolve();\n    } catch (err) {\n      return Promise.reject(err);\n    }\n  }\n  async createConnection(database, encrypted, mode, version, readonly) {\n    try {\n      if (database.endsWith('.db')) database = database.slice(0, -3);\n      await this.sqlite.createConnection({\n        database,\n        encrypted,\n        mode,\n        version,\n        readonly\n      });\n      const conn = new SQLiteDBConnection(database, readonly, this.sqlite);\n      const connName = readonly ? `RO_${database}` : `RW_${database}`;\n      this._connectionDict.set(connName, conn);\n      /*\n      console.log(`*** in createConnection connectionDict: ***`)\n      this._connectionDict.forEach((connection, key) => {\n        console.log(`Key: ${key}, Value: ${connection}`);\n      });\n      */\n      return Promise.resolve(conn);\n    } catch (err) {\n      return Promise.reject(err);\n    }\n  }\n  async closeConnection(database, readonly) {\n    try {\n      if (database.endsWith('.db')) database = database.slice(0, -3);\n      await this.sqlite.closeConnection({\n        database,\n        readonly\n      });\n      const connName = readonly ? `RO_${database}` : `RW_${database}`;\n      this._connectionDict.delete(connName);\n      /*      console.log(`*** in closeConnection connectionDict: ***`)\n      this._connectionDict.forEach((connection, key) => {\n        console.log(`Key: ${key}, Value: ${connection}`);\n      });\n      */\n      return Promise.resolve();\n    } catch (err) {\n      return Promise.reject(err);\n    }\n  }\n  async isConnection(database, readonly) {\n    const res = {};\n    if (database.endsWith('.db')) database = database.slice(0, -3);\n    const connName = readonly ? `RO_${database}` : `RW_${database}`;\n    res.result = this._connectionDict.has(connName);\n    return Promise.resolve(res);\n  }\n  async retrieveConnection(database, readonly) {\n    if (database.endsWith('.db')) database = database.slice(0, -3);\n    const connName = readonly ? `RO_${database}` : `RW_${database}`;\n    if (this._connectionDict.has(connName)) {\n      const conn = this._connectionDict.get(connName);\n      if (typeof conn != 'undefined') return Promise.resolve(conn);else {\n        return Promise.reject(`Connection ${database} is undefined`);\n      }\n    } else {\n      return Promise.reject(`Connection ${database} does not exist`);\n    }\n  }\n  async getNCDatabasePath(path, database) {\n    try {\n      const databasePath = await this.sqlite.getNCDatabasePath({\n        path,\n        database\n      });\n      return Promise.resolve(databasePath);\n    } catch (err) {\n      return Promise.reject(err);\n    }\n  }\n  async createNCConnection(databasePath, version) {\n    try {\n      await this.sqlite.createNCConnection({\n        databasePath,\n        version\n      });\n      const conn = new SQLiteDBConnection(databasePath, true, this.sqlite);\n      const connName = `RO_${databasePath})`;\n      this._connectionDict.set(connName, conn);\n      return Promise.resolve(conn);\n    } catch (err) {\n      return Promise.reject(err);\n    }\n  }\n  async closeNCConnection(databasePath) {\n    try {\n      await this.sqlite.closeNCConnection({\n        databasePath\n      });\n      const connName = `RO_${databasePath})`;\n      this._connectionDict.delete(connName);\n      return Promise.resolve();\n    } catch (err) {\n      return Promise.reject(err);\n    }\n  }\n  async isNCConnection(databasePath) {\n    const res = {};\n    const connName = `RO_${databasePath})`;\n    res.result = this._connectionDict.has(connName);\n    return Promise.resolve(res);\n  }\n  async retrieveNCConnection(databasePath) {\n    if (this._connectionDict.has(databasePath)) {\n      const connName = `RO_${databasePath})`;\n      const conn = this._connectionDict.get(connName);\n      if (typeof conn != 'undefined') return Promise.resolve(conn);else {\n        return Promise.reject(`Connection ${databasePath} is undefined`);\n      }\n    } else {\n      return Promise.reject(`Connection ${databasePath} does not exist`);\n    }\n  }\n  async isNCDatabase(databasePath) {\n    try {\n      const res = await this.sqlite.isNCDatabase({\n        databasePath\n      });\n      return Promise.resolve(res);\n    } catch (err) {\n      return Promise.reject(err);\n    }\n  }\n  async retrieveAllConnections() {\n    return this._connectionDict;\n  }\n  async closeAllConnections() {\n    const delDict = new Map();\n    try {\n      /*      console.log(`*** in closeAllConnections connectionDict: ***`)\n      this._connectionDict.forEach((connection, key) => {\n        console.log(`Key: ${key}, Value: ${connection}`);\n      });\n      */\n      for (const key of this._connectionDict.keys()) {\n        const database = key.substring(3);\n        const readonly = key.substring(0, 3) === 'RO_' ? true : false;\n        await this.sqlite.closeConnection({\n          database,\n          readonly\n        });\n        delDict.set(key, null);\n      }\n      for (const key of delDict.keys()) {\n        this._connectionDict.delete(key);\n      }\n      return Promise.resolve();\n    } catch (err) {\n      return Promise.reject(err);\n    }\n  }\n  async checkConnectionsConsistency() {\n    try {\n      const keys = [...this._connectionDict.keys()];\n      const openModes = [];\n      const dbNames = [];\n      for (const key of keys) {\n        openModes.push(key.substring(0, 2));\n        dbNames.push(key.substring(3));\n      }\n      const res = await this.sqlite.checkConnectionsConsistency({\n        dbNames: dbNames,\n        openModes: openModes\n      });\n      if (!res.result) this._connectionDict = new Map();\n      return Promise.resolve(res);\n    } catch (err) {\n      this._connectionDict = new Map();\n      return Promise.reject(err);\n    }\n  }\n  async importFromJson(jsonstring) {\n    try {\n      const ret = await this.sqlite.importFromJson({\n        jsonstring: jsonstring\n      });\n      return Promise.resolve(ret);\n    } catch (err) {\n      return Promise.reject(err);\n    }\n  }\n  async isJsonValid(jsonstring) {\n    try {\n      const ret = await this.sqlite.isJsonValid({\n        jsonstring: jsonstring\n      });\n      return Promise.resolve(ret);\n    } catch (err) {\n      return Promise.reject(err);\n    }\n  }\n  async copyFromAssets(overwrite) {\n    const mOverwrite = overwrite != null ? overwrite : true;\n    try {\n      await this.sqlite.copyFromAssets({\n        overwrite: mOverwrite\n      });\n      return Promise.resolve();\n    } catch (err) {\n      return Promise.reject(err);\n    }\n  }\n  async getFromHTTPRequest(url, overwrite) {\n    const mOverwrite = overwrite != null ? overwrite : true;\n    try {\n      await this.sqlite.getFromHTTPRequest({\n        url,\n        overwrite: mOverwrite\n      });\n      return Promise.resolve();\n    } catch (err) {\n      return Promise.reject(err);\n    }\n  }\n  async isDatabaseEncrypted(database) {\n    if (database.endsWith('.db')) database = database.slice(0, -3);\n    try {\n      const res = await this.sqlite.isDatabaseEncrypted({\n        database: database\n      });\n      return Promise.resolve(res);\n    } catch (err) {\n      return Promise.reject(err);\n    }\n  }\n  async isInConfigEncryption() {\n    try {\n      const res = await this.sqlite.isInConfigEncryption();\n      return Promise.resolve(res);\n    } catch (err) {\n      return Promise.reject(err);\n    }\n  }\n  async isInConfigBiometricAuth() {\n    try {\n      const res = await this.sqlite.isInConfigBiometricAuth();\n      return Promise.resolve(res);\n    } catch (err) {\n      return Promise.reject(err);\n    }\n  }\n  async isDatabase(database) {\n    if (database.endsWith('.db')) database = database.slice(0, -3);\n    try {\n      const res = await this.sqlite.isDatabase({\n        database: database\n      });\n      return Promise.resolve(res);\n    } catch (err) {\n      return Promise.reject(err);\n    }\n  }\n  async getDatabaseList() {\n    try {\n      const res = await this.sqlite.getDatabaseList();\n      const values = res.values;\n      values.sort();\n      const ret = {\n        values: values\n      };\n      return Promise.resolve(ret);\n    } catch (err) {\n      return Promise.reject(err);\n    }\n  }\n  async getMigratableDbList(folderPath) {\n    const path = folderPath ? folderPath : 'default';\n    try {\n      const res = await this.sqlite.getMigratableDbList({\n        folderPath: path\n      });\n      return Promise.resolve(res);\n    } catch (err) {\n      return Promise.reject(err);\n    }\n  }\n  async addSQLiteSuffix(folderPath, dbNameList) {\n    const path = folderPath ? folderPath : 'default';\n    const dbList = dbNameList ? dbNameList : [];\n    try {\n      const res = await this.sqlite.addSQLiteSuffix({\n        folderPath: path,\n        dbNameList: dbList\n      });\n      return Promise.resolve(res);\n    } catch (err) {\n      return Promise.reject(err);\n    }\n  }\n  async deleteOldDatabases(folderPath, dbNameList) {\n    const path = folderPath ? folderPath : 'default';\n    const dbList = dbNameList ? dbNameList : [];\n    try {\n      const res = await this.sqlite.deleteOldDatabases({\n        folderPath: path,\n        dbNameList: dbList\n      });\n      return Promise.resolve(res);\n    } catch (err) {\n      return Promise.reject(err);\n    }\n  }\n  async moveDatabasesAndAddSuffix(folderPath, dbNameList) {\n    const path = folderPath ? folderPath : 'default';\n    const dbList = dbNameList ? dbNameList : [];\n    return this.sqlite.moveDatabasesAndAddSuffix({\n      folderPath: path,\n      dbNameList: dbList\n    });\n  }\n}\n/**\n * SQLiteDBConnection Class\n */\nexport class SQLiteDBConnection {\n  constructor(dbName, readonly, sqlite) {\n    this.dbName = dbName;\n    this.readonly = readonly;\n    this.sqlite = sqlite;\n  }\n  getConnectionDBName() {\n    return this.dbName;\n  }\n  getConnectionReadOnly() {\n    return this.readonly;\n  }\n  async open() {\n    try {\n      await this.sqlite.open({\n        database: this.dbName,\n        readonly: this.readonly\n      });\n      return Promise.resolve();\n    } catch (err) {\n      return Promise.reject(err);\n    }\n  }\n  async close() {\n    try {\n      await this.sqlite.close({\n        database: this.dbName,\n        readonly: this.readonly\n      });\n      return Promise.resolve();\n    } catch (err) {\n      return Promise.reject(err);\n    }\n  }\n  async beginTransaction() {\n    try {\n      const changes = await this.sqlite.beginTransaction({\n        database: this.dbName\n      });\n      return Promise.resolve(changes);\n    } catch (err) {\n      return Promise.reject(err);\n    }\n  }\n  async commitTransaction() {\n    try {\n      const changes = await this.sqlite.commitTransaction({\n        database: this.dbName\n      });\n      return Promise.resolve(changes);\n    } catch (err) {\n      return Promise.reject(err);\n    }\n  }\n  async rollbackTransaction() {\n    try {\n      const changes = await this.sqlite.rollbackTransaction({\n        database: this.dbName\n      });\n      return Promise.resolve(changes);\n    } catch (err) {\n      return Promise.reject(err);\n    }\n  }\n  async isTransactionActive() {\n    try {\n      const result = await this.sqlite.isTransactionActive({\n        database: this.dbName\n      });\n      return Promise.resolve(result);\n    } catch (err) {\n      return Promise.reject(err);\n    }\n  }\n  async loadExtension(path) {\n    try {\n      await this.sqlite.loadExtension({\n        database: this.dbName,\n        path: path,\n        readonly: this.readonly\n      });\n      return Promise.resolve();\n    } catch (err) {\n      return Promise.reject(err);\n    }\n  }\n  async enableLoadExtension(toggle) {\n    try {\n      await this.sqlite.enableLoadExtension({\n        database: this.dbName,\n        toggle: toggle,\n        readonly: this.readonly\n      });\n      return Promise.resolve();\n    } catch (err) {\n      return Promise.reject(err);\n    }\n  }\n  async getUrl() {\n    try {\n      const res = await this.sqlite.getUrl({\n        database: this.dbName,\n        readonly: this.readonly\n      });\n      return Promise.resolve(res);\n    } catch (err) {\n      return Promise.reject(err);\n    }\n  }\n  async getVersion() {\n    try {\n      const version = await this.sqlite.getVersion({\n        database: this.dbName,\n        readonly: this.readonly\n      });\n      return Promise.resolve(version);\n    } catch (err) {\n      return Promise.reject(err);\n    }\n  }\n  async getTableList() {\n    try {\n      const res = await this.sqlite.getTableList({\n        database: this.dbName,\n        readonly: this.readonly\n      });\n      return Promise.resolve(res);\n    } catch (err) {\n      return Promise.reject(err);\n    }\n  }\n  async execute(statements, transaction = true, isSQL92 = true) {\n    try {\n      if (!this.readonly) {\n        const res = await this.sqlite.execute({\n          database: this.dbName,\n          statements: statements,\n          transaction: transaction,\n          readonly: false,\n          isSQL92: isSQL92\n        });\n        return Promise.resolve(res);\n      } else {\n        return Promise.reject('not allowed in read-only mode');\n      }\n    } catch (err) {\n      return Promise.reject(err);\n    }\n  }\n  async query(statement, values, isSQL92 = true) {\n    let res;\n    try {\n      if (values && values.length > 0) {\n        res = await this.sqlite.query({\n          database: this.dbName,\n          statement: statement,\n          values: values,\n          readonly: this.readonly,\n          isSQL92: true\n        });\n      } else {\n        res = await this.sqlite.query({\n          database: this.dbName,\n          statement: statement,\n          values: [],\n          readonly: this.readonly,\n          isSQL92: isSQL92\n        });\n      }\n      // reorder rows for ios\n      res = await this.reorderRows(res);\n      return Promise.resolve(res);\n    } catch (err) {\n      return Promise.reject(err);\n    }\n  }\n  async run(statement, values, transaction = true, returnMode = 'no', isSQL92 = true) {\n    let res;\n    try {\n      if (!this.readonly) {\n        if (values && values.length > 0) {\n          res = await this.sqlite.run({\n            database: this.dbName,\n            statement: statement,\n            values: values,\n            transaction: transaction,\n            readonly: false,\n            returnMode: returnMode,\n            isSQL92: true\n          });\n        } else {\n          res = await this.sqlite.run({\n            database: this.dbName,\n            statement: statement,\n            values: [],\n            transaction: transaction,\n            readonly: false,\n            returnMode: returnMode,\n            isSQL92: isSQL92\n          });\n        }\n        // reorder rows for ios\n        res.changes = await this.reorderRows(res.changes);\n        return Promise.resolve(res);\n      } else {\n        return Promise.reject('not allowed in read-only mode');\n      }\n    } catch (err) {\n      return Promise.reject(err);\n    }\n  }\n  async executeSet(set, transaction = true, returnMode = 'no', isSQL92 = true) {\n    let res;\n    try {\n      if (!this.readonly) {\n        res = await this.sqlite.executeSet({\n          database: this.dbName,\n          set: set,\n          transaction: transaction,\n          readonly: false,\n          returnMode: returnMode,\n          isSQL92: isSQL92\n        });\n        //      }\n        // reorder rows for ios\n        res.changes = await this.reorderRows(res.changes);\n        return Promise.resolve(res);\n      } else {\n        return Promise.reject('not allowed in read-only mode');\n      }\n    } catch (err) {\n      return Promise.reject(err);\n    }\n  }\n  async isExists() {\n    try {\n      const res = await this.sqlite.isDBExists({\n        database: this.dbName,\n        readonly: this.readonly\n      });\n      return Promise.resolve(res);\n    } catch (err) {\n      return Promise.reject(err);\n    }\n  }\n  async isTable(table) {\n    try {\n      const res = await this.sqlite.isTableExists({\n        database: this.dbName,\n        table: table,\n        readonly: this.readonly\n      });\n      return Promise.resolve(res);\n    } catch (err) {\n      return Promise.reject(err);\n    }\n  }\n  async isDBOpen() {\n    try {\n      const res = await this.sqlite.isDBOpen({\n        database: this.dbName,\n        readonly: this.readonly\n      });\n      return Promise.resolve(res);\n    } catch (err) {\n      return Promise.reject(err);\n    }\n  }\n  async delete() {\n    try {\n      if (!this.readonly) {\n        await this.sqlite.deleteDatabase({\n          database: this.dbName,\n          readonly: false\n        });\n        return Promise.resolve();\n      } else {\n        return Promise.reject('not allowed in read-only mode');\n      }\n    } catch (err) {\n      return Promise.reject(err);\n    }\n  }\n  async createSyncTable() {\n    try {\n      if (!this.readonly) {\n        const res = await this.sqlite.createSyncTable({\n          database: this.dbName,\n          readonly: false\n        });\n        return Promise.resolve(res);\n      } else {\n        return Promise.reject('not allowed in read-only mode');\n      }\n    } catch (err) {\n      return Promise.reject(err);\n    }\n  }\n  async setSyncDate(syncdate) {\n    try {\n      if (!this.readonly) {\n        await this.sqlite.setSyncDate({\n          database: this.dbName,\n          syncdate: syncdate,\n          readonly: false\n        });\n        return Promise.resolve();\n      } else {\n        return Promise.reject('not allowed in read-only mode');\n      }\n    } catch (err) {\n      return Promise.reject(err);\n    }\n  }\n  async getSyncDate() {\n    try {\n      const res = await this.sqlite.getSyncDate({\n        database: this.dbName,\n        readonly: this.readonly\n      });\n      let retDate = '';\n      if (res.syncDate > 0) retDate = new Date(res.syncDate * 1000).toISOString();\n      return Promise.resolve(retDate);\n    } catch (err) {\n      return Promise.reject(err);\n    }\n  }\n  async exportToJson(mode, encrypted = false) {\n    try {\n      const res = await this.sqlite.exportToJson({\n        database: this.dbName,\n        jsonexportmode: mode,\n        readonly: this.readonly,\n        encrypted: encrypted\n      });\n      return Promise.resolve(res);\n    } catch (err) {\n      return Promise.reject(err);\n    }\n  }\n  async deleteExportedRows() {\n    try {\n      if (!this.readonly) {\n        await this.sqlite.deleteExportedRows({\n          database: this.dbName,\n          readonly: false\n        });\n        return Promise.resolve();\n      } else {\n        return Promise.reject('not allowed in read-only mode');\n      }\n    } catch (err) {\n      return Promise.reject(err);\n    }\n  }\n  async executeTransaction(txn, isSQL92 = true) {\n    let changes = 0;\n    let isActive = false;\n    if (!this.readonly) {\n      await this.sqlite.beginTransaction({\n        database: this.dbName\n      });\n      isActive = await this.sqlite.isTransactionActive({\n        database: this.dbName\n      });\n      if (!isActive) {\n        return Promise.reject('After Begin Transaction, no transaction active');\n      }\n      try {\n        for (const task of txn) {\n          if (typeof task !== 'object' || !('statement' in task)) {\n            throw new Error('Error a task.statement must be provided');\n          }\n          if ('values' in task && task.values && task.values.length > 0) {\n            const retMode = task.statement.toUpperCase().includes('RETURNING') ? 'all' : 'no';\n            const ret = await this.sqlite.run({\n              database: this.dbName,\n              statement: task.statement,\n              values: task.values,\n              transaction: false,\n              readonly: false,\n              returnMode: retMode,\n              isSQL92: isSQL92\n            });\n            if (ret.changes.changes < 0) {\n              throw new Error('Error in transaction method run ');\n            }\n            changes += ret.changes.changes;\n          } else {\n            const ret = await this.sqlite.execute({\n              database: this.dbName,\n              statements: task.statement,\n              transaction: false,\n              readonly: false\n            });\n            if (ret.changes.changes < 0) {\n              throw new Error('Error in transaction method execute ');\n            }\n            changes += ret.changes.changes;\n          }\n        }\n        // commit\n        const retC = await this.sqlite.commitTransaction({\n          database: this.dbName\n        });\n        changes += retC.changes.changes;\n        const retChanges = {\n          changes: {\n            changes: changes\n          }\n        };\n        return Promise.resolve(retChanges);\n      } catch (err) {\n        // rollback\n        const msg = err.message ? err.message : err;\n        await this.sqlite.rollbackTransaction({\n          database: this.dbName\n        });\n        return Promise.reject(msg);\n      }\n    } else {\n      return Promise.reject('not allowed in read-only mode');\n    }\n  }\n  async reorderRows(res) {\n    const retRes = res;\n    if (res?.values && typeof res.values[0] === 'object') {\n      if (Object.keys(res.values[0]).includes('ios_columns')) {\n        const columnList = res.values[0]['ios_columns'];\n        const iosRes = [];\n        for (let i = 1; i < res.values.length; i++) {\n          const rowJson = res.values[i];\n          const resRowJson = {};\n          for (const item of columnList) {\n            resRowJson[item] = rowJson[item];\n          }\n          iosRes.push(resRowJson);\n        }\n        retRes['values'] = iosRes;\n      }\n    }\n    return Promise.resolve(retRes);\n  }\n}","map":{"version":3,"names":["SQLiteConnection","constructor","sqlite","_connectionDict","Map","initWebStore","Promise","resolve","err","reject","saveToStore","database","saveToLocalDisk","getFromLocalDiskToStore","overwrite","mOverwrite","echo","value","res","isSecretStored","setEncryptionSecret","passphrase","changeEncryptionSecret","oldpassphrase","clearEncryptionSecret","checkEncryptionSecret","addUpgradeStatement","upgrade","endsWith","slice","createConnection","encrypted","mode","version","readonly","conn","SQLiteDBConnection","connName","set","closeConnection","delete","isConnection","result","has","retrieveConnection","get","getNCDatabasePath","path","databasePath","createNCConnection","closeNCConnection","isNCConnection","retrieveNCConnection","isNCDatabase","retrieveAllConnections","closeAllConnections","delDict","key","keys","substring","checkConnectionsConsistency","openModes","dbNames","push","importFromJson","jsonstring","ret","isJsonValid","copyFromAssets","getFromHTTPRequest","url","isDatabaseEncrypted","isInConfigEncryption","isInConfigBiometricAuth","isDatabase","getDatabaseList","values","sort","getMigratableDbList","folderPath","addSQLiteSuffix","dbNameList","dbList","deleteOldDatabases","moveDatabasesAndAddSuffix","dbName","getConnectionDBName","getConnectionReadOnly","open","close","beginTransaction","changes","commitTransaction","rollbackTransaction","isTransactionActive","loadExtension","enableLoadExtension","toggle","getUrl","getVersion","getTableList","execute","statements","transaction","isSQL92","query","statement","length","reorderRows","run","returnMode","executeSet","isExists","isDBExists","isTable","table","isTableExists","isDBOpen","deleteDatabase","createSyncTable","setSyncDate","syncdate","getSyncDate","retDate","syncDate","Date","toISOString","exportToJson","jsonexportmode","deleteExportedRows","executeTransaction","txn","isActive","task","Error","retMode","toUpperCase","includes","retC","retChanges","msg","message","retRes","Object","columnList","iosRes","i","rowJson","resRowJson","item"],"sources":["C:\\Users\\INTEL\\Downloads\\project\\project\\node_modules\\@capacitor-community\\sqlite\\src\\definitions.ts"],"sourcesContent":["//import { Capacitor } from '@capacitor/core';\n\n/**\n * CapacitorSQLitePlugin Interface\n */\nexport interface CapacitorSQLitePlugin {\n  /**\n   * Initialize the web store\n   *\n   * @return Promise<void>\n   * @since 3.2.3-1\n   */\n\n  initWebStore(): Promise<void>;\n  /**\n   * Save database to  the web store\n   *\n   * @param options: capSQLiteOptions\n   * @return Promise<void>\n   * @since 3.2.3-1\n   */\n\n  saveToStore(options: capSQLiteOptions): Promise<void>;\n  /**\n   * Get database from local disk and save it to store\n   *\n   * @param options: capSQLiteLocalDiskOptions\n   * @return Promise<void>\n   * @since 4.6.3\n   */\n\n  getFromLocalDiskToStore(options: capSQLiteLocalDiskOptions): Promise<void>;\n  /**\n   * Save database to local disk\n   *\n   * @param options: capSQLiteOptions\n   * @return Promise<void>\n   * @since 4.6.3\n   */\n\n  saveToLocalDisk(options: capSQLiteOptions): Promise<void>;\n  /**\n   * Check if a passphrase exists in a secure store\n   *\n   * @return Promise<capSQLiteResult>\n   * @since 3.0.0-beta.13\n   */\n  isSecretStored(): Promise<capSQLiteResult>;\n  /**\n   * Store a passphrase in a secure store\n   * Update the secret of previous encrypted databases with GlobalSQLite\n   * !!! Only to be used once if you wish to encrypt database !!!\n   *\n   * @param options capSetSecretOptions\n   * @return Promise<void>\n   * @since 3.0.0-beta.13\n   */\n  setEncryptionSecret(options: capSetSecretOptions): Promise<void>;\n  /**\n   * Change the passphrase in a secure store\n   * Update the secret of previous encrypted databases with passphrase\n   * in secure store\n   *\n   * @param options capChangeSecretOptions\n   * @return Promise<void>\n   * @since 3.0.0-beta.13\n   */\n  changeEncryptionSecret(options: capChangeSecretOptions): Promise<void>;\n  /**\n   * Clear the passphrase in the secure store\n   *\n   * @return Promise<void>\n   * @since 3.5.1\n   */\n  clearEncryptionSecret(): Promise<void>;\n  /**\n   * Check encryption passphrase\n   *\n   * @return Promise<capSQLiteResult>\n   * @since 4.6.1\n   */\n\n  checkEncryptionSecret(options: capSetSecretOptions): Promise<capSQLiteResult>;\n\n  /**\n   * create a database connection\n   * @param options capConnectionOptions\n   * @return Promise<void>\n   * @since 2.9.0 refactor\n   */\n  createConnection(options: capConnectionOptions): Promise<void>;\n  /**\n   * close a database connection\n   * @param options capSQLiteOptions\n   * @return Promise<void>\n   * @since 2.9.0 refactor\n   */\n  closeConnection(options: capSQLiteOptions): Promise<void>;\n  /**\n   * Echo a given string\n   *\n   * @param options: capEchoOptions\n   * @return Promise<capEchoResult>\n   * @since 0.0.1\n   */\n  echo(options: capEchoOptions): Promise<capEchoResult>;\n  /**\n   * Opens a SQLite database.\n   * Attention: This re-opens a database if it's already open!\n   *\n   * @param options: capSQLiteOptions\n   * @returns Promise<void>\n   * @since 0.0.1\n   */\n  open(options: capSQLiteOptions): Promise<void>;\n  /**\n   * Close a SQLite database\n   * @param options: capSQLiteOptions\n   * @returns Promise<void>\n   * @since 0.0.1\n   */\n  close(options: capSQLiteOptions): Promise<void>;\n  /**\n   * Begin Database Transaction\n   * @param options\n   * @returns capSQLiteChanges\n   * @since 5.0.7\n   */\n  beginTransaction(options: capSQLiteOptions): Promise<capSQLiteChanges>;\n  /**\n   * Commit Database Transaction\n   * @param options\n   * @returns capSQLiteChanges\n   * @since 5.0.7\n   */\n  commitTransaction(options: capSQLiteOptions): Promise<capSQLiteChanges>;\n  /**\n   * Rollback Database Transaction\n   * @param options\n   * @returns capSQLiteChanges\n   * @since 5.0.7\n   */\n  rollbackTransaction(options: capSQLiteOptions): Promise<capSQLiteChanges>;\n  /**\n   * Is Database Transaction Active\n   * @param options\n   * @returns capSQLiteResult\n   * @since 5.0.7\n   */\n  isTransactionActive(options: capSQLiteOptions): Promise<capSQLiteResult>;\n  /**\n   * Load a SQlite extension\n   * @param options :capSQLiteExtensionPath\n   * @returns Promise<void>\n   * @since 5.0.6\n   */\n  //  loadExtension(options: capSQLiteExtensionPath): Promise<void>;\n  /**\n   * Enable Or Disable Extension Loading\n   * @param options\n   * @returns Promise<void>\n   * @since 5.0.6\n   */\n  //  enableLoadExtension(options: capSQLiteExtensionEnable): Promise<void>;\n  /**\n   * GetUrl get the database Url\n   * @param options: capSQLiteOptions\n   * @returns Promise<capSQLiteUrl>\n   * @since 3.3.3-4\n   */\n  getUrl(options: capSQLiteOptions): Promise<capSQLiteUrl>;\n  /**\n   * Get a SQLite database version\n   * @param options: capSQLiteOptions\n   * @returns Promise<void>\n   * @since 3.2.0\n   */\n  getVersion(options: capSQLiteOptions): Promise<capVersionResult>;\n  /**\n   * Execute a Batch of Raw Statements as String\n   * @param options: capSQLiteExecuteOptions\n   * @returns Promise<capSQLiteChanges>\n   * @since 0.0.1\n   */\n  execute(options: capSQLiteExecuteOptions): Promise<capSQLiteChanges>;\n  /**\n   * Execute a Set of Raw Statements as Array of CapSQLiteSet\n   * @param options: capSQLiteSetOptions\n   * @returns Promise<capSQLiteChanges>\n   * @since 2.2.0-2\n   */\n  executeSet(options: capSQLiteSetOptions): Promise<capSQLiteChanges>;\n  /**\n   * Execute a Single Statement\n   * @param options: capSQLiteRunOptions\n   * @returns Promise<capSQLiteChanges>\n   * @since 0.0.1\n   */\n  run(options: capSQLiteRunOptions): Promise<capSQLiteChanges>;\n  /**\n   * Query a Single Statement\n   * @param options: capSQLiteQueryOptions\n   * @returns Promise<capSQLiteValues>\n   * @since 0.0.1\n   */\n  query(options: capSQLiteQueryOptions): Promise<capSQLiteValues>;\n  /**\n   * Check if a SQLite database exists with opened connection\n   * @param options: capSQLiteOptions\n   * @returns Promise<capSQLiteResult>\n   * @since 2.0.1-1\n   */\n  isDBExists(options: capSQLiteOptions): Promise<capSQLiteResult>;\n  /**\n   * Check if a SQLite database is opened\n   * @param options: capSQLiteOptions\n   * @returns Promise<capSQLiteResult>\n   * @since 3.0.0-beta.5\n   */\n  isDBOpen(options: capSQLiteOptions): Promise<capSQLiteResult>;\n  /**\n   * Check if a SQLite database is encrypted\n   * @param options: capSQLiteOptions\n   * @returns Promise<capSQLiteResult>\n   * @since 4.6.2-2\n   */\n  isDatabaseEncrypted(options: capSQLiteOptions): Promise<capSQLiteResult>;\n  /**\n   * Check encryption value in capacitor.config\n   * @returns Promise<capSQLiteResult>\n   * @since 4.6.2-2\n   */\n  isInConfigEncryption(): Promise<capSQLiteResult>;\n  /**\n   * Check encryption value in capacitor.config\n   * @returns Promise<capSQLiteResult>\n   * @since 4.6.2-2\n   */\n  isInConfigBiometricAuth(): Promise<capSQLiteResult>;\n  /**\n   * Check if a SQLite database exists without connection\n   * @param options: capSQLiteOptions\n   * @returns Promise<capSQLiteResult>\n   * @since 3.0.0-beta.5\n   */\n  isDatabase(options: capSQLiteOptions): Promise<capSQLiteResult>;\n  /**\n   * Check if a table exists in a SQLite database\n   * @param options: capSQLiteTableOptions\n   * @returns Promise<capSQLiteResult>\n   * @since 3.0.0-beta.5\n   */\n  isTableExists(options: capSQLiteTableOptions): Promise<capSQLiteResult>;\n  /**\n   * Delete a SQLite database\n   * @param options: capSQLiteOptions\n   * @returns Promise<void>\n   * @since 0.0.1\n   */\n  deleteDatabase(options: capSQLiteOptions): Promise<void>;\n  /**\n   * Is Json Object Valid\n   * @param options: capSQLiteImportOptions\n   * @returns Promise<capSQLiteResult>\n   * @since 2.0.1-1\n   */\n  isJsonValid(options: capSQLiteImportOptions): Promise<capSQLiteResult>;\n  /**\n   * Import from Json Object\n   * @param options: capSQLiteImportOptions\n   * @returns Promise<capSQLiteChanges>\n   * @since 2.0.0-3\n   */\n  importFromJson(options: capSQLiteImportOptions): Promise<capSQLiteChanges>;\n  /**\n   * Export to Json Object\n   * @param options: capSQLiteExportOptions\n   * @returns Promise<capSQLiteJson>\n   * @since 2.0.1-1\n   */\n  exportToJson(options: capSQLiteExportOptions): Promise<capSQLiteJson>;\n  /**\n   * Create a synchronization table\n   * @param options: capSQLiteOptions\n   * @returns Promise<capSQLiteChanges>\n   * @since 2.0.1-1\n   */\n  createSyncTable(options: capSQLiteOptions): Promise<capSQLiteChanges>;\n  /**\n   * Set the synchronization date\n   * @param options: capSQLiteSyncDateOptions\n   * @returns Promise<void>\n   * @since 2.0.1-1\n   */\n  setSyncDate(options: capSQLiteSyncDateOptions): Promise<void>;\n  /**\n   * Get the synchronization date\n   * @param options: capSQLiteOptions\n   * @returns Promise<capSQLiteSyncDate>\n   * @since 2.9.0\n   */\n  getSyncDate(options: capSQLiteOptions): Promise<capSQLiteSyncDate>;\n  /**\n   * Remove rows with sql_deleted = 1 after an export\n   * @param options\n   * @returns Promise<void>\n   * @since 3.4.3-2\n   */\n  deleteExportedRows(options: capSQLiteOptions): Promise<void>;\n  /**\n   * Add the upgrade Statement for database version upgrading\n   * @param options: capSQLiteUpgradeOptions\n   * @returns Promise<void>\n   * @since 2.4.2-6 iOS & Electron 2.4.2-7 Android\n   */\n  addUpgradeStatement(options: capSQLiteUpgradeOptions): Promise<void>;\n  /**\n   * Copy databases from public/assets/databases folder to application databases folder\n   * @param options: capSQLiteFromAssets  since 3.2.5-2\n   * @returns Promise<void>\n   * @since 2.9.0 refactor\n   */\n  copyFromAssets(options: capSQLiteFromAssetsOptions): Promise<void>;\n  /**\n   * Get database or zipped database(s) from url\n   * @param options: capSQLiteHTTPOptions\n   * @returns Promise<void>\n   * @since 4.1.1\n   */\n  getFromHTTPRequest(options: capSQLiteHTTPOptions): Promise<void>;\n  /**\n   * Get the database list\n   * @returns Promise<capSQLiteValues>\n   * @since 3.0.0-beta.5\n   */\n  getDatabaseList(): Promise<capSQLiteValues>;\n  /**\n   * Get the database's table list\n   * @param options\n   * @returns Promise<capSQLiteValues>\n   * @since 3.4.2-3\n   */\n  getTableList(options: capSQLiteOptions): Promise<capSQLiteValues>;\n  /**\n   * Get the Migratable database list\n   * @param options: capSQLitePathOptions // only iOS & Android since 3.2.4-2\n   * @returns Promise<capSQLiteValues>\n   * @since 3.0.0-beta.5\n   */\n  getMigratableDbList(options: capSQLitePathOptions): Promise<capSQLiteValues>;\n  /**\n   * Add SQLIte Suffix to existing databases\n   * @param options: capSQLitePathOptions\n   * @returns Promise<void>\n   * @since 3.0.0-beta.5\n   */\n  addSQLiteSuffix(options: capSQLitePathOptions): Promise<void>;\n  /**\n   * Delete Old Cordova databases\n   * @param options: capSQLitePathOptions\n   * @returns Promise<void>\n   * @since 3.0.0-beta.5\n   */\n  deleteOldDatabases(options: capSQLitePathOptions): Promise<void>;\n  /**\n   * Moves databases to the location the plugin can read them, and adds sqlite suffix\n   * This resembles calling addSQLiteSuffix and deleteOldDatabases, but it is more performant as it doesn't copy but moves the files\n   * @param options: capSQLitePathOptions\n   */\n  moveDatabasesAndAddSuffix(options: capSQLitePathOptions): Promise<void>;\n  /**\n   * Check Connection Consistency JS <=> Native\n   * return true : consistency, connections are opened\n   * return false : no consistency, connections are closed\n   * @param options: capAllConnectionsOptions\n   * @returns Promise<capSQLiteResult>\n   * @since 3.0.0-beta.11\n   */\n  checkConnectionsConsistency(options: capAllConnectionsOptions): Promise<capSQLiteResult>;\n  /**\n   * get a non conformed database path\n   * @param options capNCDatabasePathOptions\n   * @return Promise<capNCDatabasePathResult>\n   * @since 3.3.3-1\n   */\n  getNCDatabasePath(options: capNCDatabasePathOptions): Promise<capNCDatabasePathResult>;\n  /**\n   * create a non conformed database connection\n   * @param options capNCConnectionOptions\n   * @return Promise<void>\n   * @since 3.3.3-1\n   */\n  createNCConnection(options: capNCConnectionOptions): Promise<void>;\n  /**\n   * close a non conformed database connection\n   * @param options capNCOptions\n   * @return Promise<void>\n   * @since 3.3.3-1\n   */\n  closeNCConnection(options: capNCOptions): Promise<void>;\n  /**\n   * Check if a non conformed database exists without connection\n   * @param options: capNCOptions\n   * @returns Promise<capSQLiteResult>\n   * @since 3.3.3-1\n   */\n  isNCDatabase(options: capNCOptions): Promise<capSQLiteResult>;\n}\n\nexport interface capSetSecretOptions {\n  /**\n   * The passphrase for Encrypted Databases\n   */\n  passphrase?: string;\n}\n\nexport interface capChangeSecretOptions {\n  /**\n   * The new passphrase for Encrypted Databases\n   */\n  passphrase?: string;\n  /**\n   * The old passphrase for Encrypted Databases\n   */\n  oldpassphrase?: string;\n}\nexport interface capEchoOptions {\n  /**\n   *  String to be echoed\n   */\n  value?: string;\n}\nexport interface capSQLiteExtensionPath {\n  /**\n   * The database name\n   */\n  database?: string;\n  /**\n   * The extension path\n   */\n  path?: string;\n  /**\n   * ReadOnly / ReadWrite\n   * default ReadWrite (false)\n   * @since 4.1.0-7\n   */\n  readonly?: boolean;\n}\nexport interface capSQLiteExtensionEnable {\n  /**\n   * The database name\n   */\n  database?: string;\n  /**\n   * The enabling toggle (1: ON, 0: OFF)\n   */\n  toggle?: boolean;\n  /**\n   * ReadOnly / ReadWrite\n   * default ReadWrite (false)\n   * @since 4.1.0-7\n   */\n  readonly?: boolean;\n}\nexport interface capConnectionOptions {\n  /**\n   * The database name\n   */\n  database?: string;\n  /**\n   * The database  version\n   */\n  version?: number;\n  /**\n   * Set to true (database encryption) / false\n   */\n  encrypted?: boolean;\n  /**\n   * Set the mode for database encryption\n   * [\"encryption\", \"secret\", \"newsecret\"]\n   */\n  mode?: string;\n  /**\n   * Set to true (database in read-only mode) / false\n   */\n  readonly?: boolean;\n}\nexport interface capAllConnectionsOptions {\n  /**\n   * the dbName of all connections\n   * @since 3.0.0-beta.10\n   */\n  dbNames?: string[];\n  /**\n   * the openMode (\"RW\" read&write, \"RO\" readonly) of all connections\n   * @since 4.1.0\n   */\n  openModes?: string[];\n}\nexport interface capSQLiteOptions {\n  /**\n   * The database name\n   */\n  database?: string;\n  /**\n   * Set to true (database in read-only mode) / false\n   */\n  readonly?: boolean;\n}\n\nexport interface capNCDatabasePathOptions {\n  /**\n   * the database path\n   */\n  path?: string;\n  /**\n   * The database name\n   */\n  database?: string;\n}\nexport interface capNCConnectionOptions {\n  /**\n   * The database path\n   */\n  databasePath?: string;\n  /**\n   * The database  version\n   */\n  version?: number;\n}\n\nexport interface capNCOptions {\n  /**\n   * The database path\n   */\n  databasePath?: string;\n}\nexport interface capSQLiteExecuteOptions {\n  /**\n   * The database name\n   */\n  database?: string;\n  /**\n   * The batch of raw SQL statements as string\n   */\n  statements?: string;\n  /**\n   * Enable / Disable transactions\n   * default Enable (true)\n   * @since 3.0.0-beta.10\n   */\n  transaction?: boolean;\n  /**\n   * ReadOnly / ReadWrite\n   * default ReadWrite (false)\n   * @since 4.1.0-7\n   */\n  readonly?: boolean;\n  /**\n   * Compatibility SQL92\n   * !!! ELECTRON ONLY\n   * default (true)\n   * @since 5.0.7\n   */\n  isSQL92?: boolean;\n}\nexport interface capSQLiteSetOptions {\n  /**\n   * The database name\n   */\n  database?: string;\n  /**\n   * The batch of raw SQL statements as Array of capSQLLiteSet\n   */\n  set?: capSQLiteSet[];\n  /**\n   * Enable / Disable transactions\n   * default Enable (true)\n   * @since 3.0.0-beta.10\n   */\n  transaction?: boolean;\n  /**\n   * ReadOnly / ReadWrite\n   * default ReadWrite (false)\n   * @since 4.1.0-7\n   */\n  readonly?: boolean;\n  /**\n   * return mode\n   * default 'no'\n   * value 'all'\n   * value 'one' for Electron platform\n   * @since 5.0.5-3\n   */\n  returnMode?: string;\n  /**\n   * Compatibility SQL92\n   * !!! ELECTRON ONLY\n   * default (true)\n   * @since 5.0.7\n   */\n  isSQL92?: boolean;\n}\nexport interface capSQLiteRunOptions {\n  /**\n   * The database name\n   */\n  database?: string;\n  /**\n   * A statement\n   */\n  statement?: string;\n  /**\n   * A set of values for a statement\n   */\n  values?: any[];\n  /**\n   * Enable / Disable transactions\n   * default Enable (true)\n   * @since 3.0.0-beta.10\n   */\n  transaction?: boolean;\n  /**\n   * ReadOnly / ReadWrite\n   * default ReadWrite (false)\n   * @since 4.1.0-7\n   */\n  readonly?: boolean;\n  /**\n   * return mode\n   * default 'no'\n   * value 'all'\n   * value 'one' for Electron platform\n   * @since 5.0.5-3\n   */\n  returnMode?: string;\n  /**\n   * Compatibility SQL92\n   * !!! ELECTRON ONLY\n   * default (true)\n   * @since 5.0.7\n   */\n  isSQL92?: boolean;\n}\nexport interface capSQLiteQueryOptions {\n  /**\n   * The database name\n   */\n  database?: string;\n  /**\n   * A statement\n   */\n  statement?: string;\n  /**\n   * A set of values for a statement\n   * Change to any[]\n   * @since 3.0.0-beta.11\n   */\n  values?: any[];\n  /**\n   * ReadOnly / ReadWrite\n   * default ReadWrite (false)\n   * @since 4.1.0-7\n   */\n  readonly?: boolean;\n  /**\n   * Compatibility SQL92\n   * !!! ELECTRON ONLY\n   * default (true)\n   * @since 5.0.7\n   */\n  isSQL92?: boolean;\n}\nexport interface capTask {\n  /**\n   * define task for executeTransaction\n   * @since 5.6.3\n   */\n  /**\n   * A SQLite statement\n   */\n  statement: string;\n  /**\n   * A set of values to bind to the statement (optional)\n   */\n  values?: any[];\n}\nexport interface capSQLiteImportOptions {\n  /**\n   * Set the JSON object to import\n   *\n   */\n  jsonstring?: string;\n}\nexport interface capSQLiteExportOptions {\n  /**\n   * The database name\n   */\n  database?: string;\n  /**\n   * Set the mode to export JSON Object:\n   * \"full\" or \"partial\"\n   *\n   */\n  jsonexportmode?: string;\n  /**\n   * ReadOnly / ReadWrite\n   * default ReadWrite (false)\n   * @since 4.1.0-7\n   */\n  readonly?: boolean;\n  /**\n   * Encrypted\n   * When your database is encrypted\n   * Choose the export Json Object\n   * Encrypted (true) / Unencrypted (false)\n   * default false\n   * @since 5.0.8\n   */\n  encrypted?: boolean;\n}\nexport interface capSQLiteFromAssetsOptions {\n  /**\n   * Set the overwrite mode for the copy from assets\n   * \"true\"/\"false\"  default to \"true\"\n   *\n   */\n  overwrite?: boolean;\n}\nexport interface capSQLiteLocalDiskOptions {\n  /**\n   * Set the overwrite mode for saving the database from local disk to store\n   * \"true\"/\"false\"  default to \"true\"\n   *\n   */\n  overwrite?: boolean;\n}\nexport interface capSQLiteHTTPOptions {\n  /**\n   * The url of the database or the zipped database(s)\n   */\n  url?: string;\n\n  /**\n   * Set the overwrite mode for the copy from assets\n   * \"true\"/\"false\"  default to \"true\"\n   *\n   */\n  overwrite?: boolean;\n}\nexport interface capSQLiteSyncDateOptions {\n  /**\n   * The database name\n   */\n  database?: string;\n  /**\n   * Set the synchronization date\n   * Format yyyy-MM-dd'T'HH:mm:ss.SSSZ\n   */\n  syncdate?: string;\n  /**\n   * ReadOnly / ReadWrite\n   * default ReadWrite (false)\n   * @since 4.1.0-7\n   */\n  readonly?: boolean;\n}\nexport interface capSQLiteSet {\n  /**\n   * A statement\n   */\n  statement?: string;\n  /**\n   * the data values list as an Array\n   */\n  values?: any[];\n}\nexport interface capSQLiteUpgradeOptions {\n  /**\n   * The database name\n   */\n  database?: string;\n  /**\n   * The upgrade options for version upgrade\n   * Array of length 1 to easiest the iOS plugin\n   */\n  upgrade?: capSQLiteVersionUpgrade[];\n}\nexport interface capSQLitePathOptions {\n  /**\n   * The folder path of existing databases\n   * If not given folder path is \"default\"\n   */\n  folderPath?: string;\n  /**\n   * The database name's list to be copied and/or deleted\n   * since 3.2.4-1\n   * If not given all databases in the specify folder path\n   */\n  dbNameList?: string[];\n}\nexport interface capSQLiteTableOptions {\n  /**\n   * The database name\n   */\n  database?: string;\n  /**\n   * The table name\n   */\n  table?: string;\n  /**\n   * ReadOnly / ReadWrite\n   * default ReadWrite (false)\n   * @since 4.1.0-7\n   */\n  readonly?: boolean;\n}\nexport interface capEchoResult {\n  /**\n   * String returned\n   */\n  value?: string;\n}\nexport interface capNCDatabasePathResult {\n  /**\n   * String returned\n   */\n  path?: string;\n}\nexport interface capVersionResult {\n  /**\n   * Number returned\n   */\n  version?: number;\n}\nexport interface capSQLiteResult {\n  /**\n   * result set to true when successful else false\n   */\n  result?: boolean;\n}\nexport interface capSQLiteUrl {\n  /**\n   * a returned url\n   */\n  url?: string;\n}\nexport interface capSQLiteChanges {\n  /**\n   * a returned Changes\n   */\n  changes?: Changes;\n}\nexport interface Changes {\n  /**\n   * the number of changes from an execute or run command\n   */\n  changes?: number;\n  /**\n   * the lastId created from a run command\n   */\n  lastId?: number;\n  /**\n   * values when RETURNING\n   */\n  values?: any[];\n}\nexport interface capSQLiteValues {\n  /**\n   * the data values list as an Array\n   * iOS the first row is the returned ios_columns name list\n   */\n  values?: any[];\n}\nexport interface DBSQLiteValues {\n  /**\n   * the data values list as an Array\n   */\n  values?: any[];\n}\nexport interface capSQLiteJson {\n  /**\n   * an export JSON object\n   */\n  export?: JsonSQLite;\n}\nexport interface capSQLiteSyncDate {\n  /**\n   * the synchronization date\n   */\n  syncDate?: number;\n}\n\n/* JSON Types */\nexport interface EncryptJson {\n  /**\n   * The encrypted JsonSQLite base64 string\n   */\n  expData: string;\n}\nexport interface JsonSQLite {\n  /**\n   * The database name\n   */\n  database: string;\n  /**\n   *  The database version\n   */\n  version: number;\n  /**\n   * Delete the database prior to import (default false)\n   */\n  overwrite?: boolean;\n  /**\n   * Set to true (database encryption) / false\n   */\n  encrypted: boolean;\n  /***\n   * Set the mode\n   * [\"full\", \"partial\"]\n   */\n  mode: string;\n  /***\n   * Array of Table (JsonTable)\n   */\n  tables: JsonTable[];\n  /***\n   * Array of View (JsonView)\n   */\n  views?: JsonView[];\n}\nexport interface JsonTable {\n  /**\n   * The database name\n   */\n  name: string;\n  /***\n   * Array of Schema (JsonColumn)\n   */\n  schema?: JsonColumn[];\n  /***\n   * Array of Index (JsonIndex)\n   */\n  indexes?: JsonIndex[];\n  /***\n   * Array of Trigger (JsonTrigger)\n   */\n  triggers?: JsonTrigger[];\n  /***\n   * Array of Table data\n   */\n  values?: any[][];\n}\nexport interface JsonColumn {\n  /**\n   * The column name\n   */\n  column?: string;\n  /**\n   * The column data (type, unique, ...)\n   */\n  value: string;\n  /**\n   * The column foreign key constraints\n   */\n  foreignkey?: string;\n  /**\n   * the column constraint\n   */\n  constraint?: string;\n}\nexport interface JsonTrigger {\n  /**\n   * The trigger name\n   */\n  name: string;\n  /**\n   * The trigger time event fired\n   */\n  timeevent: string;\n\n  /**\n   * The trigger condition\n   */\n  condition?: string;\n\n  /**\n   * The logic of the trigger\n   */\n  logic: string;\n}\nexport interface JsonIndex {\n  /**\n   * The index name\n   */\n  name: string;\n  /**\n   * The value of the index can have the following formats:\n   * email\n   * email ASC\n   * email, MobileNumber\n   * email ASC, MobileNumber DESC\n   */\n  value: string;\n  /**\n   * the mode (Optional)\n   * UNIQUE\n   */\n  mode?: string;\n}\nexport interface JsonView {\n  /**\n   * The view name\n   */\n  name: string;\n  /**\n   * The view create statement\n   */\n  value: string;\n}\nexport interface capBiometricListener {\n  /**\n   * Biometric ready\n   */\n  result: boolean;\n  message: string;\n}\nexport interface capJsonProgressListener {\n  /**\n   * Progress message\n   */\n  progress?: string;\n}\nexport interface capHttpRequestEndedListener {\n  /**\n   * Message\n   */\n  message?: string;\n}\nexport interface capPickOrSaveDatabaseEndedListener {\n  /**\n   * Pick Database's name\n   */\n  db_name?: string;\n  /**\n   * Message\n   */\n  message?: string;\n}\nexport interface capSQLiteVersionUpgrade {\n  toVersion: number;\n  statements: string[];\n}\n\n/**\n * SQLiteConnection Interface\n */\nexport interface ISQLiteConnection {\n  /**\n   * Init the web store\n   * @returns Promise<void>\n   * @since 3.2.3-1\n   */\n  initWebStore(): Promise<void>;\n  /**\n   * Save the datbase to the web store\n   * @param database\n   * @returns Promise<void>\n   * @since 3.2.3-1\n   */\n  saveToStore(database: string): Promise<void>;\n  /**\n   * Get database from local disk and save it to store\n   *\n   * @param overwrite: boolean\n   * @return Promise<void>\n   * @since 4.6.3\n   */\n  getFromLocalDiskToStore(overwrite: boolean): Promise<void>;\n  /**\n   * Save database to local disk\n   *\n   * @param database: string\n   * @return Promise<void>\n   * @since 4.6.3\n   */\n  saveToLocalDisk(database: string): Promise<void>;\n  /**\n   * Echo a value\n   * @param value\n   * @returns Promise<capEchoResult>\n   * @since 2.9.0 refactor\n   */\n  echo(value: string): Promise<capEchoResult>;\n  /**\n   * Check if a secret is stored\n   * @returns Promise<capSQLiteResult>\n   * @since 3.0.0-beta.13\n   */\n  isSecretStored(): Promise<capSQLiteResult>;\n\n  /**\n   * Set a passphrase in a secure store\n   * @param passphrase\n   * @returns Promise<void>\n   * @since 3.0.0-beta.13\n   */\n  setEncryptionSecret(passphrase: string): Promise<void>;\n  /**\n   * Change the passphrase in a secure store\n   * @param passphrase\n   * @param oldpassphrase\n   * @returns Promise<void>\n   * @since 3.0.0-beta.13\n   */\n  changeEncryptionSecret(passphrase: string, oldpassphrase: string): Promise<void>;\n  /**\n   * Clear the passphrase in a secure store\n   * @returns Promise<void>\n   * @since 3.5.1\n   */\n  clearEncryptionSecret(): Promise<void>;\n  /**\n   * Check the passphrase stored in a secure store\n   * @param oldPassphrase\n   * @returns Promise<capSQLiteResult>\n   * @since 4.6.1\n   */\n  checkEncryptionSecret(passphrase: string): Promise<capSQLiteResult>;\n  /**\n   * Add the upgrade Statement for database version upgrading\n   * @param database\n   * @param upgrade @since 5.6.4\n   * @returns Promise<void>\n   * @since 2.9.0 refactor\n   */\n  addUpgradeStatement(database: string, upgrade: capSQLiteVersionUpgrade[]): Promise<void>;\n  /**\n   * Create a connection to a database\n   * @param database\n   * @param encrypted\n   * @param mode\n   * @param version\n   * @param readonly\n   * @returns Promise<SQLiteDBConnection>\n   * @since 2.9.0 refactor\n   */\n  createConnection(\n    database: string,\n    encrypted: boolean,\n    mode: string,\n    version: number,\n    readonly: boolean,\n  ): Promise<SQLiteDBConnection>;\n  /**\n   * Check if a connection exists\n   * @param database\n   * @param readonly\n   * @returns Promise<capSQLiteResult>\n   * @since 3.0.0-beta.5\n   */\n  isConnection(database: string, readonly: boolean): Promise<capSQLiteResult>;\n  /**\n   * Retrieve an existing database connection\n   * @param database\n   * @param readonly\n   * @returns Promise<SQLiteDBConnection>\n   * @since 2.9.0 refactor\n   */\n  retrieveConnection(database: string, readonly: boolean): Promise<SQLiteDBConnection>;\n  /**\n   * Retrieve all database connections\n   * @returns Promise<Map<string, SQLiteDBConnection>>\n   * @since 2.9.0 refactor\n   */\n  retrieveAllConnections(): Promise<Map<string, SQLiteDBConnection>>;\n  /**\n   * Close a database connection\n   * @param database\n   * @param readonly\n   * @returns Promise<void>\n   * @since 2.9.0 refactor\n   */\n  closeConnection(database: string, readonly: boolean): Promise<void>;\n  /**\n   * Close all database connections\n   * @returns Promise<void>\n   * @since 2.9.0 refactor\n   */\n  closeAllConnections(): Promise<void>;\n  /**\n   * Check the consistency between Js Connections\n   * and Native Connections\n   * if inconsistency all connections are removed\n   * @returns Promise<capSQLiteResult>\n   * @since 3.0.0-beta.10\n   */\n  checkConnectionsConsistency(): Promise<capSQLiteResult>;\n  /**\n   * get a non-conformed database path\n   * @param path\n   * @param database\n   * @returns Promise<capNCDatabasePathResult>\n   * @since 3.3.3-1\n   */\n  getNCDatabasePath(path: string, database: string): Promise<capNCDatabasePathResult>;\n  /**\n   * Create a non-conformed database connection\n   * @param databasePath\n   * @param version\n   * @returns Promise<SQLiteDBConnection>\n   * @since 3.3.3-1\n   */\n  createNCConnection(databasePath: string, version: number): Promise<SQLiteDBConnection>;\n  /**\n   * Close a non-conformed database connection\n   * @param databasePath\n   * @returns Promise<void>\n   * @since 3.3.3-1\n   */\n  closeNCConnection(databasePath: string): Promise<void>;\n  /**\n   * Check if a non-conformed databaseconnection exists\n   * @param databasePath\n   * @returns Promise<capSQLiteResult>\n   * @since 3.3.3-1\n   */\n  isNCConnection(databasePath: string): Promise<capSQLiteResult>;\n  /**\n   * Retrieve an existing non-conformed database connection\n   * @param databasePath\n   * @returns Promise<SQLiteDBConnection>\n   * @since 3.3.3-1\n   */\n  retrieveNCConnection(databasePath: string): Promise<SQLiteDBConnection>;\n\n  /**\n   * Import a database From a JSON\n   * @param jsonstring string\n   * @returns Promise<capSQLiteChanges>\n   * @since 2.9.0 refactor\n   */\n  importFromJson(jsonstring: string): Promise<capSQLiteChanges>;\n  /**\n   * Check the validity of a JSON Object\n   * @param jsonstring string\n   * @returns Promise<capSQLiteResult>\n   * @since 2.9.0 refactor\n   */\n  isJsonValid(jsonstring: string): Promise<capSQLiteResult>;\n  /**\n   * Copy databases from public/assets/databases folder to application databases folder\n   * @param overwrite  since 3.2.5-2\n   * @returns Promise<void>\n   * @since 2.9.0 refactor\n   */\n  copyFromAssets(overwrite?: boolean): Promise<void>;\n  /**\n   *\n   * @param url\n   * @param overwrite\n   * @returns Promise<void>\n   * @since 4.1.1\n   */\n  getFromHTTPRequest(url?: string, overwrite?: boolean): Promise<void>;\n  /**\n   * Check if a SQLite database is encrypted\n   * @param options: capSQLiteOptions\n   * @returns Promise<capSQLiteResult>\n   * @since 4.6.2-2\n   */\n  isDatabaseEncrypted(database: string): Promise<capSQLiteResult>;\n  /**\n   * Check encryption value in capacitor.config\n   * @returns Promise<capSQLiteResult>\n   * @since 4.6.2-2\n   */\n  isInConfigEncryption(): Promise<capSQLiteResult>;\n  /**\n   * Check encryption value in capacitor.config\n   * @returns Promise<capSQLiteResult>\n   * @since 4.6.2-2\n   */\n  isInConfigBiometricAuth(): Promise<capSQLiteResult>;\n  /**\n   * Check if a database exists\n   * @param database\n   * @returns Promise<capSQLiteResult>\n   * @since 3.0.0-beta.5\n   */\n  isDatabase(database: string): Promise<capSQLiteResult>;\n  /**\n   * Check if a non conformed database exists\n   * @param databasePath\n   * @returns Promise<capSQLiteResult>\n   * @since 3.3.3-1\n   */\n  isNCDatabase(databasePath: string): Promise<capSQLiteResult>;\n  /**\n   * Get the database list\n   * @returns Promise<capSQLiteValues>\n   * @since 3.0.0-beta.5\n   */\n  getDatabaseList(): Promise<capSQLiteValues>;\n  /**\n   * Get the Migratable database list\n   * @param folderPath: string // only iOS & Android since 3.2.4-2\n   * @returns Promise<capSQLiteValues>\n   * @since 3.0.0-beta.5\n   */\n  getMigratableDbList(folderPath?: string): Promise<capSQLiteValues>;\n\n  /**\n   * Add SQLIte Suffix to existing databases\n   * @param folderPath\n   * @param dbNameList since 3.2.4-1\n   * @returns Promise<void>\n   * @since 3.0.0-beta.5\n   */\n  addSQLiteSuffix(folderPath?: string, dbNameList?: string[]): Promise<void>;\n  /**\n   * Delete Old Cordova databases\n   * @param folderPath\n   * @param dbNameList since 3.2.4-1\n   * @returns Promise<void>\n   * @since 3.0.0-beta.5\n   */\n  deleteOldDatabases(folderPath?: string, dbNameList?: string[]): Promise<void>;\n  /**\n   * Moves databases to the location the plugin can read them, and adds sqlite suffix\n   * This resembles calling addSQLiteSuffix and deleteOldDatabases, but it is more performant as it doesn't copy but moves the files\n   * @param folderPath the origin from where to move the databases\n   * @param dbNameList the names of the databases to move, check out the getMigratableDbList to get a list, an empty list will result in copying all the databases with '.db' extension.\n   */\n  moveDatabasesAndAddSuffix(folderPath?: string, dbNameList?: string[]): Promise<void>;\n}\n/**\n * SQLiteConnection Class\n */\nexport class SQLiteConnection implements ISQLiteConnection {\n  private _connectionDict: Map<string, SQLiteDBConnection> = new Map();\n  constructor(private sqlite: any) {}\n\n  async initWebStore(): Promise<void> {\n    try {\n      await this.sqlite.initWebStore();\n      return Promise.resolve();\n    } catch (err) {\n      return Promise.reject(err);\n    }\n  }\n  async saveToStore(database: string): Promise<void> {\n    try {\n      await this.sqlite.saveToStore({ database });\n      return Promise.resolve();\n    } catch (err) {\n      return Promise.reject(err);\n    }\n  }\n  async saveToLocalDisk(database: string): Promise<void> {\n    try {\n      await this.sqlite.saveToLocalDisk({ database });\n      return Promise.resolve();\n    } catch (err) {\n      return Promise.reject(err);\n    }\n  }\n  async getFromLocalDiskToStore(overwrite?: boolean): Promise<void> {\n    const mOverwrite: boolean = overwrite != null ? overwrite : true;\n\n    try {\n      await this.sqlite.getFromLocalDiskToStore({ overwrite: mOverwrite });\n      return Promise.resolve();\n    } catch (err) {\n      return Promise.reject(err);\n    }\n  }\n\n  async echo(value: string): Promise<capEchoResult> {\n    try {\n      const res = await this.sqlite.echo({ value });\n      return Promise.resolve(res);\n    } catch (err) {\n      return Promise.reject(err);\n    }\n  }\n  async isSecretStored(): Promise<capSQLiteResult> {\n    try {\n      const res: capSQLiteResult = await this.sqlite.isSecretStored();\n      return Promise.resolve(res);\n    } catch (err) {\n      return Promise.reject(err);\n    }\n  }\n\n  async setEncryptionSecret(passphrase: string): Promise<void> {\n    try {\n      await this.sqlite.setEncryptionSecret({ passphrase: passphrase });\n      return Promise.resolve();\n    } catch (err) {\n      return Promise.reject(err);\n    }\n  }\n  async changeEncryptionSecret(passphrase: string, oldpassphrase: string): Promise<void> {\n    try {\n      await this.sqlite.changeEncryptionSecret({\n        passphrase: passphrase,\n        oldpassphrase: oldpassphrase,\n      });\n      return Promise.resolve();\n    } catch (err) {\n      return Promise.reject(err);\n    }\n  }\n  async clearEncryptionSecret(): Promise<void> {\n    try {\n      await this.sqlite.clearEncryptionSecret();\n      return Promise.resolve();\n    } catch (err) {\n      return Promise.reject(err);\n    }\n  }\n  async checkEncryptionSecret(passphrase: string): Promise<capSQLiteResult> {\n    try {\n      const res: capSQLiteResult = await this.sqlite.checkEncryptionSecret({\n        passphrase: passphrase,\n      });\n      return Promise.resolve(res);\n    } catch (err) {\n      return Promise.reject(err);\n    }\n  }\n  async addUpgradeStatement(database: string, upgrade: capSQLiteVersionUpgrade[]): Promise<void> {\n    try {\n      if (database.endsWith('.db')) database = database.slice(0, -3);\n      await this.sqlite.addUpgradeStatement({\n        database,\n        upgrade,\n      });\n      return Promise.resolve();\n    } catch (err) {\n      return Promise.reject(err);\n    }\n  }\n  async createConnection(\n    database: string,\n    encrypted: boolean,\n    mode: string,\n    version: number,\n    readonly: boolean,\n  ): Promise<SQLiteDBConnection> {\n    try {\n      if (database.endsWith('.db')) database = database.slice(0, -3);\n      await this.sqlite.createConnection({\n        database,\n        encrypted,\n        mode,\n        version,\n        readonly,\n      });\n      const conn = new SQLiteDBConnection(database, readonly, this.sqlite);\n      const connName = readonly ? `RO_${database}` : `RW_${database}`;\n      this._connectionDict.set(connName, conn);\n      /*\n      console.log(`*** in createConnection connectionDict: ***`)\n      this._connectionDict.forEach((connection, key) => {\n        console.log(`Key: ${key}, Value: ${connection}`);\n      });\n*/\n      return Promise.resolve(conn);\n    } catch (err) {\n      return Promise.reject(err);\n    }\n  }\n  async closeConnection(database: string, readonly: boolean): Promise<void> {\n    try {\n      if (database.endsWith('.db')) database = database.slice(0, -3);\n      await this.sqlite.closeConnection({ database, readonly });\n      const connName = readonly ? `RO_${database}` : `RW_${database}`;\n      this._connectionDict.delete(connName);\n      /*      console.log(`*** in closeConnection connectionDict: ***`)\n      this._connectionDict.forEach((connection, key) => {\n        console.log(`Key: ${key}, Value: ${connection}`);\n      });\n*/\n      return Promise.resolve();\n    } catch (err) {\n      return Promise.reject(err);\n    }\n  }\n  async isConnection(database: string, readonly: boolean): Promise<capSQLiteResult> {\n    const res: capSQLiteResult = {} as capSQLiteResult;\n    if (database.endsWith('.db')) database = database.slice(0, -3);\n    const connName = readonly ? `RO_${database}` : `RW_${database}`;\n    res.result = this._connectionDict.has(connName);\n    return Promise.resolve(res);\n  }\n  async retrieveConnection(database: string, readonly: boolean): Promise<SQLiteDBConnection> {\n    if (database.endsWith('.db')) database = database.slice(0, -3);\n    const connName = readonly ? `RO_${database}` : `RW_${database}`;\n    if (this._connectionDict.has(connName)) {\n      const conn = this._connectionDict.get(connName);\n      if (typeof conn != 'undefined') return Promise.resolve(conn);\n      else {\n        return Promise.reject(`Connection ${database} is undefined`);\n      }\n    } else {\n      return Promise.reject(`Connection ${database} does not exist`);\n    }\n  }\n  async getNCDatabasePath(path: string, database: string): Promise<capNCDatabasePathResult> {\n    try {\n      const databasePath: capNCDatabasePathResult = await this.sqlite.getNCDatabasePath({\n        path,\n        database,\n      });\n      return Promise.resolve(databasePath);\n    } catch (err) {\n      return Promise.reject(err);\n    }\n  }\n  async createNCConnection(databasePath: string, version: number): Promise<SQLiteDBConnection> {\n    try {\n      await this.sqlite.createNCConnection({\n        databasePath,\n        version,\n      });\n      const conn = new SQLiteDBConnection(databasePath, true, this.sqlite);\n      const connName = `RO_${databasePath})`;\n      this._connectionDict.set(connName, conn);\n      return Promise.resolve(conn);\n    } catch (err) {\n      return Promise.reject(err);\n    }\n  }\n  async closeNCConnection(databasePath: string): Promise<void> {\n    try {\n      await this.sqlite.closeNCConnection({ databasePath });\n      const connName = `RO_${databasePath})`;\n      this._connectionDict.delete(connName);\n      return Promise.resolve();\n    } catch (err) {\n      return Promise.reject(err);\n    }\n  }\n  async isNCConnection(databasePath: string): Promise<capSQLiteResult> {\n    const res: capSQLiteResult = {} as capSQLiteResult;\n    const connName = `RO_${databasePath})`;\n    res.result = this._connectionDict.has(connName);\n    return Promise.resolve(res);\n  }\n  async retrieveNCConnection(databasePath: string): Promise<SQLiteDBConnection> {\n    if (this._connectionDict.has(databasePath)) {\n      const connName = `RO_${databasePath})`;\n      const conn = this._connectionDict.get(connName);\n      if (typeof conn != 'undefined') return Promise.resolve(conn);\n      else {\n        return Promise.reject(`Connection ${databasePath} is undefined`);\n      }\n    } else {\n      return Promise.reject(`Connection ${databasePath} does not exist`);\n    }\n  }\n  async isNCDatabase(databasePath: string): Promise<capSQLiteResult> {\n    try {\n      const res = await this.sqlite.isNCDatabase({ databasePath });\n      return Promise.resolve(res);\n    } catch (err) {\n      return Promise.reject(err);\n    }\n  }\n\n  async retrieveAllConnections(): Promise<Map<string, SQLiteDBConnection>> {\n    return this._connectionDict;\n  }\n  async closeAllConnections(): Promise<void> {\n    const delDict: Map<string, SQLiteDBConnection | null> = new Map();\n    try {\n      /*      console.log(`*** in closeAllConnections connectionDict: ***`)\n      this._connectionDict.forEach((connection, key) => {\n        console.log(`Key: ${key}, Value: ${connection}`);\n      });\n*/\n      for (const key of this._connectionDict.keys()) {\n        const database = key.substring(3);\n        const readonly = key.substring(0, 3) === 'RO_' ? true : false;\n        await this.sqlite.closeConnection({ database, readonly });\n        delDict.set(key, null);\n      }\n\n      for (const key of delDict.keys()) {\n        this._connectionDict.delete(key);\n      }\n      return Promise.resolve();\n    } catch (err) {\n      return Promise.reject(err);\n    }\n  }\n  async checkConnectionsConsistency(): Promise<capSQLiteResult> {\n    try {\n      const keys = [...this._connectionDict.keys()];\n      const openModes: string[] = [];\n      const dbNames: string[] = [];\n      for (const key of keys) {\n        openModes.push(key.substring(0, 2));\n        dbNames.push(key.substring(3));\n      }\n      const res: capSQLiteResult = await this.sqlite.checkConnectionsConsistency({\n        dbNames: dbNames,\n        openModes: openModes,\n      });\n      if (!res.result) this._connectionDict = new Map();\n      return Promise.resolve(res);\n    } catch (err) {\n      this._connectionDict = new Map();\n      return Promise.reject(err);\n    }\n  }\n  async importFromJson(jsonstring: string): Promise<capSQLiteChanges> {\n    try {\n      const ret = await this.sqlite.importFromJson({ jsonstring: jsonstring });\n      return Promise.resolve(ret);\n    } catch (err) {\n      return Promise.reject(err);\n    }\n  }\n  async isJsonValid(jsonstring: string): Promise<capSQLiteResult> {\n    try {\n      const ret = await this.sqlite.isJsonValid({ jsonstring: jsonstring });\n      return Promise.resolve(ret);\n    } catch (err) {\n      return Promise.reject(err);\n    }\n  }\n  async copyFromAssets(overwrite?: boolean): Promise<void> {\n    const mOverwrite: boolean = overwrite != null ? overwrite : true;\n\n    try {\n      await this.sqlite.copyFromAssets({ overwrite: mOverwrite });\n      return Promise.resolve();\n    } catch (err) {\n      return Promise.reject(err);\n    }\n  }\n  async getFromHTTPRequest(url: string, overwrite?: boolean): Promise<void> {\n    const mOverwrite: boolean = overwrite != null ? overwrite : true;\n    try {\n      await this.sqlite.getFromHTTPRequest({ url, overwrite: mOverwrite });\n      return Promise.resolve();\n    } catch (err) {\n      return Promise.reject(err);\n    }\n  }\n  async isDatabaseEncrypted(database: string): Promise<capSQLiteResult> {\n    if (database.endsWith('.db')) database = database.slice(0, -3);\n    try {\n      const res = await this.sqlite.isDatabaseEncrypted({ database: database });\n      return Promise.resolve(res);\n    } catch (err) {\n      return Promise.reject(err);\n    }\n  }\n  async isInConfigEncryption(): Promise<capSQLiteResult> {\n    try {\n      const res = await this.sqlite.isInConfigEncryption();\n      return Promise.resolve(res);\n    } catch (err) {\n      return Promise.reject(err);\n    }\n  }\n  async isInConfigBiometricAuth(): Promise<capSQLiteResult> {\n    try {\n      const res = await this.sqlite.isInConfigBiometricAuth();\n      return Promise.resolve(res);\n    } catch (err) {\n      return Promise.reject(err);\n    }\n  }\n  async isDatabase(database: string): Promise<capSQLiteResult> {\n    if (database.endsWith('.db')) database = database.slice(0, -3);\n    try {\n      const res = await this.sqlite.isDatabase({ database: database });\n      return Promise.resolve(res);\n    } catch (err) {\n      return Promise.reject(err);\n    }\n  }\n  async getDatabaseList(): Promise<capSQLiteValues> {\n    try {\n      const res = await this.sqlite.getDatabaseList();\n      const values: string[] = res.values;\n      values.sort();\n      const ret = { values: values };\n      return Promise.resolve(ret);\n    } catch (err) {\n      return Promise.reject(err);\n    }\n  }\n  async getMigratableDbList(folderPath?: string): Promise<capSQLiteValues> {\n    const path: string = folderPath ? folderPath : 'default';\n    try {\n      const res = await this.sqlite.getMigratableDbList({\n        folderPath: path,\n      });\n      return Promise.resolve(res);\n    } catch (err) {\n      return Promise.reject(err);\n    }\n  }\n  async addSQLiteSuffix(folderPath?: string, dbNameList?: string[]): Promise<void> {\n    const path: string = folderPath ? folderPath : 'default';\n    const dbList: string[] = dbNameList ? dbNameList : [];\n    try {\n      const res = await this.sqlite.addSQLiteSuffix({\n        folderPath: path,\n        dbNameList: dbList,\n      });\n      return Promise.resolve(res);\n    } catch (err) {\n      return Promise.reject(err);\n    }\n  }\n  async deleteOldDatabases(folderPath?: string, dbNameList?: string[]): Promise<void> {\n    const path: string = folderPath ? folderPath : 'default';\n    const dbList: string[] = dbNameList ? dbNameList : [];\n    try {\n      const res = await this.sqlite.deleteOldDatabases({\n        folderPath: path,\n        dbNameList: dbList,\n      });\n      return Promise.resolve(res);\n    } catch (err) {\n      return Promise.reject(err);\n    }\n  }\n\n  async moveDatabasesAndAddSuffix(folderPath?: string, dbNameList?: string[]): Promise<void> {\n    const path: string = folderPath ? folderPath : 'default';\n    const dbList: string[] = dbNameList ? dbNameList : [];\n    return this.sqlite.moveDatabasesAndAddSuffix({\n      folderPath: path,\n      dbNameList: dbList,\n    });\n  }\n}\n\n/**\n * SQLiteDBConnection Interface\n */\nexport interface ISQLiteDBConnection {\n  /**\n   * Get SQLite DB Connection DB name\n   * @returns string\n   * @since 2.9.0 refactor\n   */\n  getConnectionDBName(): string;\n\n  /**\n   * Get SQLite DB Connection read-only mode\n   * @returns boolean\n   * @since 4.1.0\n   */\n  getConnectionReadOnly(): boolean;\n\n  /**\n   * Open a SQLite DB Connection\n   * @returns Promise<void>\n   * @since 2.9.0 refactor\n   */\n  open(): Promise<void>;\n  /**\n   * Close a SQLite DB Connection\n   * @returns Promise<void>\n   * @since 2.9.0 refactor\n   */\n  close(): Promise<void>;\n  /**\n   * Begin Database Transaction\n   * @returns capSQLiteChanges\n   * @since 5.0.7\n   */\n  beginTransaction(): Promise<capSQLiteChanges>;\n  /**\n   * Commit Database Transaction\n   * @returns capSQLiteChanges\n   * @since 5.0.7\n   */\n  commitTransaction(): Promise<capSQLiteChanges>;\n  /**\n   * Rollback Database Transaction\n   * @returns capSQLiteChanges\n   * @since 5.0.7\n   */\n  rollbackTransaction(): Promise<capSQLiteChanges>;\n  /**\n   * Is Database Transaction Active\n   * @returns capSQLiteResult\n   * @since 5.0.7\n   */\n  isTransactionActive(): Promise<capSQLiteResult>;\n  /**\n   * Get Database Url\n   * @returns Promise<capSQLiteUrl>\n   * @since 3.3.3-4\n   */\n  getUrl(): Promise<capSQLiteUrl>;\n  /**\n   * Get the a SQLite DB Version\n   * @returns Promise<capVersionResult>\n   * @since 3.2.0\n   */\n  getVersion(): Promise<capVersionResult>;\n  /**\n   * Load a SQlite extension\n   * @param path :SQlite extension path\n   * @returns Promise<void>\n   * @since 5.0.6\n   */\n  loadExtension(path: string): Promise<void>;\n  /**\n   * Enable Or Disable Extension Loading\n   * @param toggle true:on false:off\n   * @returns Promise<void>\n   * @since 5.0.6\n   */\n  enableLoadExtension(toggle: boolean): Promise<void>;\n  /**\n   * Execute SQLite DB Connection Statements\n   * @param statements\n   * @param transaction (optional)\n   * @param isSQL92 (optional)\n   * @returns Promise<capSQLiteChanges>\n   * @since 2.9.0 refactor\n   */\n  execute(statements: string, transaction?: boolean, isSQL92?: boolean): Promise<capSQLiteChanges>;\n  /**\n   * Execute SQLite DB Connection Query\n   * @param statement\n   * @param values (optional)\n   * @param isSQL92 (optional)\n   * @returns Promise<Promise<DBSQLiteValues>\n   * @since 2.9.0 refactor\n   */\n  query(statement: string, values?: any[], isSQL92?: boolean): Promise<DBSQLiteValues>;\n  /**\n   * Execute SQLite DB Connection Raw Statement\n   * @param statement\n   * @param values (optional)\n   * @param transaction (optional)\n   * @param returnMode (optional)\n   * @param isSQL92 (optional)\n   * @returns Promise<capSQLiteChanges>\n   * @since 2.9.0 refactor\n   */\n  run(\n    statement: string,\n    values?: any[],\n    transaction?: boolean,\n    returnMode?: string,\n    isSQL92?: boolean,\n  ): Promise<capSQLiteChanges>;\n  /**\n   * Execute SQLite DB Connection Set\n   * @param set\n   * @param transaction (optional)\n   * @param returnMode (optional)\n   * @param isSQL92 (optional)\n   * @returns Promise<capSQLiteChanges>\n   * @since 2.9.0 refactor\n   */\n  executeSet(\n    set: capSQLiteSet[],\n    transaction?: boolean,\n    returnMode?: string,\n    isSQL92?: boolean,\n  ): Promise<capSQLiteChanges>;\n  /**\n   * Check if a SQLite DB Connection exists\n   * @returns Promise<capSQLiteResult>\n   * @since 2.9.0 refactor\n   */\n  isExists(): Promise<capSQLiteResult>;\n  /**\n   * Check if a SQLite database is opened\n   * @returns Promise<capSQLiteResult>\n   * @since 3.0.0-beta.5\n   */\n  isDBOpen(): Promise<capSQLiteResult>;\n  /**\n   * Check if a table exists\n   * @returns Promise<capSQLiteResult>\n   * @since 3.0.0-beta.5\n   */\n  isTable(table: string): Promise<capSQLiteResult>;\n  /**\n   * Get database's table list\n   * @since 3.4.2-3\n   */\n  getTableList(): Promise<DBSQLiteValues>;\n  /**\n   * Delete a SQLite DB Connection\n   * @returns Promise<void>\n   * @since 2.9.0 refactor\n   */\n  delete(): Promise<void>;\n  /**\n   * Create a synchronization table\n   * @returns Promise<capSQLiteChanges>\n   * @since 2.9.0 refactor\n   */\n  createSyncTable(): Promise<capSQLiteChanges>;\n  /**\n   * Set the synchronization date\n   * @param syncdate\n   * @returns Promise<void>\n   * @since 2.9.0 refactor\n   */\n  setSyncDate(syncdate: string): Promise<void>;\n  /**\n   * Get the synchronization date\n   * @returns Promise<capSQLiteSyncDate>\n   * @since 2.9.0 refactor\n   */\n  getSyncDate(): Promise<string>;\n  /**\n   * Export the given database to a JSON Object\n   * @param mode\n   * @param encrypted (optional) since 5.0.8 not for Web platform\n   * @returns Promise<capSQLiteJson>\n   * @since 2.9.0 refactor\n   */\n  exportToJson(mode: string, encrypted?: boolean): Promise<capSQLiteJson>;\n  /**\n   * Remove rows with sql_deleted = 1 after an export\n   * @returns Promise<void>\n   * @since 3.4.3-2\n   */\n  deleteExportedRows(): Promise<void>;\n\n  /**\n   *\n   * @param txn\n   * @param isSQL92\n   * @returns Promise<capSQLiteChanges> since 5.0.7\n   * @since 3.4.0\n   */\n  executeTransaction(txn: capTask[], isSQL92: boolean): Promise<capSQLiteChanges>;\n}\n/**\n * SQLiteDBConnection Class\n */\nexport class SQLiteDBConnection implements ISQLiteDBConnection {\n  constructor(\n    private dbName: string,\n    private readonly: boolean,\n    private sqlite: any,\n  ) {}\n\n  getConnectionDBName(): string {\n    return this.dbName;\n  }\n  getConnectionReadOnly(): boolean {\n    return this.readonly;\n  }\n\n  async open(): Promise<void> {\n    try {\n      await this.sqlite.open({\n        database: this.dbName,\n        readonly: this.readonly,\n      });\n      return Promise.resolve();\n    } catch (err) {\n      return Promise.reject(err);\n    }\n  }\n  async close(): Promise<void> {\n    try {\n      await this.sqlite.close({\n        database: this.dbName,\n        readonly: this.readonly,\n      });\n      return Promise.resolve();\n    } catch (err) {\n      return Promise.reject(err);\n    }\n  }\n  async beginTransaction(): Promise<capSQLiteChanges> {\n    try {\n      const changes: capSQLiteChanges = await this.sqlite.beginTransaction({\n        database: this.dbName,\n      });\n      return Promise.resolve(changes);\n    } catch (err) {\n      return Promise.reject(err);\n    }\n  }\n  async commitTransaction(): Promise<capSQLiteChanges> {\n    try {\n      const changes: capSQLiteChanges = await this.sqlite.commitTransaction({\n        database: this.dbName,\n      });\n      return Promise.resolve(changes);\n    } catch (err) {\n      return Promise.reject(err);\n    }\n  }\n  async rollbackTransaction(): Promise<capSQLiteChanges> {\n    try {\n      const changes: capSQLiteChanges = await this.sqlite.rollbackTransaction({\n        database: this.dbName,\n      });\n      return Promise.resolve(changes);\n    } catch (err) {\n      return Promise.reject(err);\n    }\n  }\n  async isTransactionActive(): Promise<capSQLiteResult> {\n    try {\n      const result: capSQLiteResult = await this.sqlite.isTransactionActive({\n        database: this.dbName,\n      });\n      return Promise.resolve(result);\n    } catch (err) {\n      return Promise.reject(err);\n    }\n  }\n\n  async loadExtension(path: string): Promise<void> {\n    try {\n      await this.sqlite.loadExtension({\n        database: this.dbName,\n        path: path,\n        readonly: this.readonly,\n      });\n      return Promise.resolve();\n    } catch (err) {\n      return Promise.reject(err);\n    }\n  }\n  async enableLoadExtension(toggle: boolean): Promise<void> {\n    try {\n      await this.sqlite.enableLoadExtension({\n        database: this.dbName,\n        toggle: toggle,\n        readonly: this.readonly,\n      });\n      return Promise.resolve();\n    } catch (err) {\n      return Promise.reject(err);\n    }\n  }\n\n  async getUrl(): Promise<capSQLiteUrl> {\n    try {\n      const res: capSQLiteUrl = await this.sqlite.getUrl({\n        database: this.dbName,\n        readonly: this.readonly,\n      });\n      return Promise.resolve(res);\n    } catch (err) {\n      return Promise.reject(err);\n    }\n  }\n  async getVersion(): Promise<capVersionResult> {\n    try {\n      const version: capVersionResult = await this.sqlite.getVersion({\n        database: this.dbName,\n        readonly: this.readonly,\n      });\n      return Promise.resolve(version);\n    } catch (err) {\n      return Promise.reject(err);\n    }\n  }\n  async getTableList(): Promise<DBSQLiteValues> {\n    try {\n      const res: any = await this.sqlite.getTableList({\n        database: this.dbName,\n        readonly: this.readonly,\n      });\n      return Promise.resolve(res);\n    } catch (err) {\n      return Promise.reject(err);\n    }\n  }\n  async execute(statements: string, transaction = true, isSQL92 = true): Promise<capSQLiteChanges> {\n    try {\n      if (!this.readonly) {\n        const res: any = await this.sqlite.execute({\n          database: this.dbName,\n          statements: statements,\n          transaction: transaction,\n          readonly: false,\n          isSQL92: isSQL92,\n        });\n        return Promise.resolve(res);\n      } else {\n        return Promise.reject('not allowed in read-only mode');\n      }\n    } catch (err) {\n      return Promise.reject(err);\n    }\n  }\n  async query(statement: string, values?: any[], isSQL92 = true): Promise<DBSQLiteValues> {\n    let res: any;\n    try {\n      if (values && values.length > 0) {\n        res = await this.sqlite.query({\n          database: this.dbName,\n          statement: statement,\n          values: values,\n          readonly: this.readonly,\n          isSQL92: true,\n        });\n      } else {\n        res = await this.sqlite.query({\n          database: this.dbName,\n          statement: statement,\n          values: [],\n          readonly: this.readonly,\n          isSQL92: isSQL92,\n        });\n      }\n\n      // reorder rows for ios\n      res = await this.reorderRows(res);\n      return Promise.resolve(res);\n    } catch (err) {\n      return Promise.reject(err);\n    }\n  }\n  async run(\n    statement: string,\n    values?: any[],\n    transaction = true,\n    returnMode = 'no',\n    isSQL92 = true,\n  ): Promise<capSQLiteChanges> {\n    let res: any;\n    try {\n      if (!this.readonly) {\n        if (values && values.length > 0) {\n          res = await this.sqlite.run({\n            database: this.dbName,\n            statement: statement,\n            values: values,\n            transaction: transaction,\n            readonly: false,\n            returnMode: returnMode,\n            isSQL92: true,\n          });\n        } else {\n          res = await this.sqlite.run({\n            database: this.dbName,\n            statement: statement,\n            values: [],\n            transaction: transaction,\n            readonly: false,\n            returnMode: returnMode,\n            isSQL92: isSQL92,\n          });\n        }\n        // reorder rows for ios\n        res.changes = await this.reorderRows(res.changes);\n        return Promise.resolve(res);\n      } else {\n        return Promise.reject('not allowed in read-only mode');\n      }\n    } catch (err) {\n      return Promise.reject(err);\n    }\n  }\n  async executeSet(\n    set: capSQLiteSet[],\n    transaction = true,\n    returnMode = 'no',\n    isSQL92 = true,\n  ): Promise<capSQLiteChanges> {\n    let res: any;\n    try {\n      if (!this.readonly) {\n        res = await this.sqlite.executeSet({\n          database: this.dbName,\n          set: set,\n          transaction: transaction,\n          readonly: false,\n          returnMode: returnMode,\n          isSQL92: isSQL92,\n        });\n        //      }\n        // reorder rows for ios\n        res.changes = await this.reorderRows(res.changes);\n        return Promise.resolve(res);\n      } else {\n        return Promise.reject('not allowed in read-only mode');\n      }\n    } catch (err) {\n      return Promise.reject(err);\n    }\n  }\n  async isExists(): Promise<capSQLiteResult> {\n    try {\n      const res: any = await this.sqlite.isDBExists({\n        database: this.dbName,\n        readonly: this.readonly,\n      });\n      return Promise.resolve(res);\n    } catch (err) {\n      return Promise.reject(err);\n    }\n  }\n  async isTable(table: string): Promise<capSQLiteResult> {\n    try {\n      const res: capSQLiteResult = await this.sqlite.isTableExists({\n        database: this.dbName,\n        table: table,\n        readonly: this.readonly,\n      });\n      return Promise.resolve(res);\n    } catch (err) {\n      return Promise.reject(err);\n    }\n  }\n  async isDBOpen(): Promise<capSQLiteResult> {\n    try {\n      const res: capSQLiteResult = await this.sqlite.isDBOpen({\n        database: this.dbName,\n        readonly: this.readonly,\n      });\n      return Promise.resolve(res);\n    } catch (err) {\n      return Promise.reject(err);\n    }\n  }\n  async delete(): Promise<void> {\n    try {\n      if (!this.readonly) {\n        await this.sqlite.deleteDatabase({\n          database: this.dbName,\n          readonly: false,\n        });\n        return Promise.resolve();\n      } else {\n        return Promise.reject('not allowed in read-only mode');\n      }\n    } catch (err) {\n      return Promise.reject(err);\n    }\n  }\n  async createSyncTable(): Promise<capSQLiteChanges> {\n    try {\n      if (!this.readonly) {\n        const res: any = await this.sqlite.createSyncTable({\n          database: this.dbName,\n          readonly: false,\n        });\n        return Promise.resolve(res);\n      } else {\n        return Promise.reject('not allowed in read-only mode');\n      }\n    } catch (err) {\n      return Promise.reject(err);\n    }\n  }\n  async setSyncDate(syncdate: string): Promise<void> {\n    try {\n      if (!this.readonly) {\n        await this.sqlite.setSyncDate({\n          database: this.dbName,\n          syncdate: syncdate,\n          readonly: false,\n        });\n        return Promise.resolve();\n      } else {\n        return Promise.reject('not allowed in read-only mode');\n      }\n    } catch (err) {\n      return Promise.reject(err);\n    }\n  }\n  async getSyncDate(): Promise<string> {\n    try {\n      const res: any = await this.sqlite.getSyncDate({\n        database: this.dbName,\n        readonly: this.readonly,\n      });\n      let retDate = '';\n      if (res.syncDate > 0) retDate = new Date(res.syncDate * 1000).toISOString();\n      return Promise.resolve(retDate);\n    } catch (err) {\n      return Promise.reject(err);\n    }\n  }\n  async exportToJson(mode: string, encrypted = false): Promise<capSQLiteJson> {\n    try {\n      const res: any = await this.sqlite.exportToJson({\n        database: this.dbName,\n        jsonexportmode: mode,\n        readonly: this.readonly,\n        encrypted: encrypted,\n      });\n      return Promise.resolve(res);\n    } catch (err) {\n      return Promise.reject(err);\n    }\n  }\n  async deleteExportedRows(): Promise<void> {\n    try {\n      if (!this.readonly) {\n        await this.sqlite.deleteExportedRows({\n          database: this.dbName,\n          readonly: false,\n        });\n        return Promise.resolve();\n      } else {\n        return Promise.reject('not allowed in read-only mode');\n      }\n    } catch (err) {\n      return Promise.reject(err);\n    }\n  }\n\n  async executeTransaction(txn: capTask[], isSQL92 = true): Promise<capSQLiteChanges> {\n    let changes = 0;\n    let isActive = false;\n    if (!this.readonly) {\n      await this.sqlite.beginTransaction({\n        database: this.dbName,\n      });\n      isActive = await this.sqlite.isTransactionActive({\n        database: this.dbName,\n      });\n      if (!isActive) {\n        return Promise.reject('After Begin Transaction, no transaction active');\n      }\n      try {\n        for (const task of txn) {\n          if (typeof task !== 'object' || !('statement' in task)) {\n            throw new Error('Error a task.statement must be provided');\n          }\n          if ('values' in task && task.values && task.values.length > 0) {\n            const retMode = task.statement.toUpperCase().includes('RETURNING') ? 'all' : 'no';\n            const ret = await this.sqlite.run({\n              database: this.dbName,\n              statement: task.statement,\n              values: task.values,\n              transaction: false,\n              readonly: false,\n              returnMode: retMode,\n              isSQL92: isSQL92,\n            });\n            if (ret.changes.changes < 0) {\n              throw new Error('Error in transaction method run ');\n            }\n            changes += ret.changes.changes;\n          } else {\n            const ret = await this.sqlite.execute({\n              database: this.dbName,\n              statements: task.statement,\n              transaction: false,\n              readonly: false,\n            });\n            if (ret.changes.changes < 0) {\n              throw new Error('Error in transaction method execute ');\n            }\n            changes += ret.changes.changes;\n          }\n        }\n        // commit\n        const retC = await this.sqlite.commitTransaction({\n          database: this.dbName,\n        });\n        changes += retC.changes.changes;\n        const retChanges = { changes: { changes: changes } };\n        return Promise.resolve(retChanges);\n      } catch (err: any) {\n        // rollback\n        const msg = err.message ? err.message : err;\n        await this.sqlite.rollbackTransaction({\n          database: this.dbName,\n        });\n        return Promise.reject(msg);\n      }\n    } else {\n      return Promise.reject('not allowed in read-only mode');\n    }\n  }\n  private async reorderRows(res: any): Promise<any> {\n    const retRes: any = res;\n    if (res?.values && typeof res.values[0] === 'object') {\n      if (Object.keys(res.values[0]).includes('ios_columns')) {\n        const columnList: string[] = res.values[0]['ios_columns'];\n        const iosRes: any[] = [];\n        for (let i = 1; i < res.values.length; i++) {\n          const rowJson: any = res.values[i];\n          const resRowJson: any = {};\n          for (const item of columnList) {\n            resRowJson[item] = rowJson[item];\n          }\n          iosRes.push(resRowJson);\n        }\n        retRes['values'] = iosRes;\n      }\n    }\n\n    return Promise.resolve(retRes);\n  }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}